name: Release [demand]
# TODO research using the github api instead of cloning repo
on:
  workflow_dispatch:
    # TODO add input for pre-calculated version

env:
  zip_file: artifacts.zip
  tar_file: artifacts.tar.gz
  zip_artifact: "test-zip"
  tar_artifact: "test-tar"
  main_branch: "main"
  LABEL_DELIMITTER: ", "
  GH_TOKEN: ${{ secrets.YNPUT_BOT_TOKEN }}

jobs:
  merge-to-main:
    runs-on: ubuntu-latest

    steps:
      - name: ‚¨áÔ∏è Checkout ${{ env.main_branch }}
        uses: actions/checkout@v4
        with:
          ref: ${{ env.main_branch }}
          fetch-depth: 0

      - name: üîë Set Bot Authentication
        run: |
          git config --global user.email "${{ secrets.CI_EMAIL }}"
          git config --global user.name "${{ secrets.CI_USER }}"

      - name: üîÄ Merge ${{ github.ref_name }} -> ${{ env.main_branch }}
        run: |
          git pull origin ${{ github.ref_name }}
          git merge --no-ff origin/${{ github.ref_name }} -m "[Automated] Merged ${{ github.ref_name }} -> ${{ env.main_branch }}"

      - name: üîè Push to protected main branch
        uses: CasperWA/push-protected@v2.15.0
        with:
          token: ${{ secrets.YNPUT_BOT_TOKEN }}
          branch: ${{ env.main_branch }}
          tags: true
          unprotect_reviews: true

  get-pr-labels:
    runs-on: ubuntu-latest
    outputs:
      label_list: ${{ steps.merged_pr_labels.outputs.label_list }}

    steps:
      - name: üìÖ Get the last release date
        id: last_release_date
        run: |
          last_release=$(gh release list --repo ${{ github.repository }} --limit 1 | awk '{print $4 " " $5 " " $6}')
          echo "last_release=$last_release" >> $GITHUB_OUTPUT

      - name: üè∑Ô∏è Get labels of merged PRs since last release
        id: merged_pr_labels
        env:
          release_date: ${{ steps.last_release_date.outputs.last_release_date }}
        # INFO last line conversion is required since $GITHUB_OUPUT doesn't except multi-line strings
        run: |
          json_data_pr_labels=$(gh pr list --state merged --search "merged:>=${{ steps.last_release_date.outputs.last_release }}" --json labels --repo ${{ github.repository }} )
          pr_label_list=$(echo "$json_data_pr_labels" | jq -r '.[].labels[].name' | sort | uniq | tr '\n' '${{ env.LABEL_DELIMITTER }}')
          label_list=${pr_label_list%,}
          echo "label_list=$label_list" >> $GITHUB_OUTPUT
  
  calculate-version-bump:
    runs-on: ubuntu-latest
    needs: get-pr-labels
    outputs:
      next_version_proposal:

    steps:
      - name: üîç Check for valid labels
        id: valid_version_label
        env:
          LABEL_LIST: ${{ needs.get-pr-labels.outputs.label_list }}
          MINOR_LABEL: ${{ vars.MINOR_BUMP_LABEL }}
          PATCH_LABEL: ${{ vars.PATCH_BUMP_LABEL }}
        run: |
          # INFO convert csv string to bash arrays
          # TODO fix up first line so they can be handled in a streamilned way
          IFS=',' read -r -a label_list <<< "${{ env.LABEL_LIST }}"
          IFS='${{ env.LABEL_DELIMITTER }}' read -r -a minor_patterns <<< "${{ env.MINOR_LABEL }}"
          IFS='${{ env.LABEL_DELIMITTER }}' read -r -a patch_patterns <<< "${{ env.PATCH_LABEL }}"
          minor_patch=${{ env.PATCH_LABEL }}

          echo "pr_labels=${label_list[*]}" >> $GITHUB_OUTPUT

          for label in ${minor_patterns[@]}; do
            if echo "${label_list[*]}" | grep -iqFe "$label"; then
              echo "version_increment=minor" >> $GITHUB_OUTPUT
              exit 0
            fi
          done

          for label in ${patch_patterns[@]}; do
            if echo "${label_list[*]}" | grep -iqFe "$label"; then
              echo "version_increment=patch" >> $GITHUB_OUTPUT
              exit 0
            fi
          done

      - name: ‚ùó Validate labels
        run: |
          echo "version increment ${{ steps.valid_version_label.outputs.version_increment }}"

          if [ -z "${{ steps.valid_version_label.outputs.version_increment }}" ]; then
            # TODO Format using line breaks - not supported by annotations
            echo "::error:: No valid versioning labels found in PRs. Only found these labels: ${{ steps.valid_version_label.outputs.pr_labels }}. Are you sure you want to create a new release?"
            exit 1
          fi

  build-from-main:
    runs-on: ubuntu-latest
    needs: 
      - merge-to-main
      - calculate-version-bump

    steps:
      - name: ‚¨áÔ∏è Checkout ${{ env.main_branch }}
        uses: actions/checkout@v4
        with:
          ref: ${{ env.main_branch }}
          fetch-depth: 0

      # INFO placeholder artifact for repo-dependent modification
      - name: Create artifacts
        run: |
          zip -r ${{ env.zip_file }} . -x "*/\.*"
          tar -czvf ${{ env.tar_file }} --exclude=".*" .
      
      - name: üîº Upload zip artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.zip_artifact }}
          path: |
            ${{ env.zip_file }}

      - name: üîº Upload tar.gz artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.tar_artifact }}
          path: |
            ${{ env.tar_file }}


  update-develop:
    runs-on: ubuntu-latest
    needs: merge-to-main

    steps:
      - name: ‚¨áÔ∏è Checkout ${{ github.ref_name }}
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
          fetch-depth: 0

      - name: üîë Set Bot Authentication
        run: |
          # INFO might also require bit token first
          git config --global user.email "${{ secrets.CI_EMAIL }}"
          git config --global user.name "${{ secrets.CI_USER }}"

      - name: üîÅ Merge ${{ env.main_branch }} -> ${{ github.ref_name }}
        run: |
          git pull origin ${{ env.main_branch }}
          git merge origin/${{ env.main_branch }} -m "[Automated] Merged ${{ env.main_branch }} -> ${{ github.ref_name }}"
          git push origin ${{ github.ref_name }}


  create-release:
    runs-on: ubuntu-latest
    needs: 
      - build-from-main
      - calculate-version-bump
    outputs:
      release_major: ${{ steps.version.outputs.major-version }}
      release_minor: ${{ steps.version.outputs.minor-version }}
      release_patch: ${{ steps.version.outputs.patch-version }}

    steps:
      # TODO dive into the action as reference to implement custom actions
      - name: üîº Get next version
        uses: reecetech/version-increment@2024.4.4
        id: version
        with:
          scheme: semver
          increment: ${{ needs.calculate-version-bump.outputs.next_version_proposal }}
          release_branch: main
          use_api: true

      - name: üîΩ Download zip artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.zip_artifact }}

      - name: üîΩ Download tar artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.tar_artifact }}

      - name: üöÄ Create Github Release Draft
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ env.major }}.${{ env.minor }}.${{ env.patch }}
          generateReleaseNotes: true
          artifacts: ${{ env.zip_file }}, ${{ env.tar_file }}
          token: ${{ secrets.YNPUT_BOT_TOKEN }}
          draft: true
        env:
          major: ${{ steps.version.outputs.major-version }}
          minor: ${{ steps.version.outputs.minor-version }}
          patch: ${{ steps.version.outputs.patch-version }}


  verify-release:
    runs-on: ubuntu-latest
    needs: create-release
    env:
      release_major: ${{ needs.create-release.outputs.release_major }}
      release_minor: ${{ needs.create-release.outputs.release_minor }}
      release_patch: ${{ needs.create-release.outputs.release_patch }}

    steps:
      - name: Fetch Current Release Draft
        id: fetch-current-release-draft
        run: |
          current_release_name=$(gh api repos/octocat/Hello-World/releases --jq '.[] | select(.draft == true) | .name')
          echo "current_release_name=$current_release_name" >> GITHUB_OUTPUT

      - name: üîç Check Release-Draft Name
        id: check-release-tag
        env:
          expected_release_draft: "${{ env.release_major }}.${{ env.release_minor}}.${{ env.release_patch}}"
          current_release_draft: ${{ steps.fetch-current-release-draft.outputs.current_release_name }}

        run: |
          if [ "${{ env.expected_release_draft }}" == "${{ env.current_release_draft }}" ]; then
            echo "Success: Release found with the expected tag $release_tag."
            exit 0
          fi

          echo "Error: Expected tag ${{ env.expected_release_draft }}, but found ${{ env.current_release_draft }}."
          exit 1
